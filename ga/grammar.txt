# Production rules
<expr> := <button_action> <button>
        | <sensor_action> <sensor>
        | wait # 아무것도 하지 않음
<button_action> := pressButton | releaseButton
<button> := b1 | b2
<sensor_action> := ...
<sensor> := s1 | s2 이런식으로 다른 컴퍼넌트에 대해서도 추가

# Terminals
T = {pressButton, releaseButton, b1, b2}

# Non-terminals
N =  {expr, button_action, button}

# Start symbol
S = <expr>

================================================================
1. script 에서 공백 개수를 구해, codons의 길이 결정

e.g. Button.py -> 6개의 공백(space) -> length 가 6인 codons 만들기
'''
while True:
    <공백1> r
    buttonState = p2.value() # digitalRead
    <공백2> p
    if buttonState == 1:
        <공백3> w
        p1.value(1)
        <공백4> w
    else:
        <공백5> r
        p1.value(0)
        <공백6> p
    utime.sleep(1) # sleep은 무시!
'''


2. codons 만들고 phenotype(실제 인터렉션)으로 매핑
매핑 방법: {codon} mod {# of productions}
* codons란? list of integers
    * codon은 codons의 integer 하나하나를 가리킴
* productions란? production rule을 통해 만들 수 있는 모든 표현 (input)

e.g.
productions = [pressButton b1, releaseButton b1, wait]
# of productions = 3 -> {codon} mod 3
codons = [834564] mapped to 201201
interactions = [wait, pressButton b1, releaseButton b1, wait, pressButton b1, releaseButton b1]


3. 매핑된 interaction을 순서대로 공백에 삽입하기, 그리고 eval